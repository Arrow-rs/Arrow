use bytes::{Bytes, BytesMut};

use arrow_protocol::types::{varint::*, Serialize};

macro_rules! test {
    ($ty:ident; $($val:literal == [$($b:literal),*]),*) => {
        let mut buf = BytesMut::new();

        $(
            {
                let varint = $ty($val);
                let bytes = [$($b),*].as_slice();

                varint.serialize(&mut buf);

                assert_eq!(buf, bytes);
                assert_eq!(varint, $ty::deserialize(&mut Bytes::from(bytes)).unwrap());
                buf.clear();
            }
        )*
    };
}

#[test]
fn varint() {
    test! {
        VarInt;
        0x0 == [0x0],
        0x1 == [0x1],
        0x2 == [0x2],
        0x7f == [0x7f],
        0x80 == [0x80, 0x01],
        0xff == [0xff, 0x01],
        0x63dd == [0xdd, 0xc7, 0x01],
        0x1fffff == [0xff, 0xff, 0x7f],
        0x7fffffff == [0xff, 0xff, 0xff, 0xff, 0x07],
        -0x01 == [0xff, 0xff, 0xff, 0xff, 0x0f],
        -0x80000000 == [0x80, 0x80, 0x80, 0x80, 0x08]
    }
}

#[test]
fn varlong() {
    test! {
        VarLong;
        0x0 == [0x0],
        0x1 == [0x1],
        0x2 == [0x2],
        0x7f == [0x7f],
        0x80 == [0x80, 0x01],
        0xff == [0xff, 0x01],
        0x7fffffff == [0xff, 0xff, 0xff, 0xff, 0x07],
        0x7fffffffffffffff == [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f],
        -0x01 == [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01],
        -0x80000000 == [0x80, 0x80, 0x80, 0x80, 0xf8, 0xff, 0xff, 0xff, 0xff, 0x01],
        -0x8000000000000000 == [0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x01]
    }
}
